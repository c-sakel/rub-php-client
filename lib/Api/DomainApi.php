<?php
/**
 * DomainApi
 * PHP version 5
 *
 * @category Class
 * @package  c-sakel\RUBClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * RESELLING.SERVICES API
 *
 * Auf folgender Seite finden Sie die Beschreibung der RESELLING.SERVICES Schnittstelle  <!--<a href=\"https://reselling.services/api-docs?lang=en\" title=\"Englische Dokumentation\">Dokumentation in Englisch</a>-->
 *
 * OpenAPI spec version: 1.9.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.56
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace c-sakel\RUBClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use c-sakel\RUBClient\ApiException;
use c-sakel\RUBClient\Configuration;
use c-sakel\RUBClient\HeaderSelector;
use c-sakel\RUBClient\ObjectSerializer;

/**
 * DomainApi Class Doc Comment
 *
 * @category Class
 * @package  c-sakel\RUBClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DomainApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation domainAuthcode
     *
     * Domain Authinfo abrufen
     *
     * @param  string $domain_name Domain, wofür der Authcode abgerufen werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function domainAuthcode($domain_name)
    {
        $this->domainAuthcodeWithHttpInfo($domain_name);
    }

    /**
     * Operation domainAuthcodeWithHttpInfo
     *
     * Domain Authinfo abrufen
     *
     * @param  string $domain_name Domain, wofür der Authcode abgerufen werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainAuthcodeWithHttpInfo($domain_name)
    {
        $returnType = '';
        $request = $this->domainAuthcodeRequest($domain_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation domainAuthcodeAsync
     *
     * Domain Authinfo abrufen
     *
     * @param  string $domain_name Domain, wofür der Authcode abgerufen werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainAuthcodeAsync($domain_name)
    {
        return $this->domainAuthcodeAsyncWithHttpInfo($domain_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainAuthcodeAsyncWithHttpInfo
     *
     * Domain Authinfo abrufen
     *
     * @param  string $domain_name Domain, wofür der Authcode abgerufen werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainAuthcodeAsyncWithHttpInfo($domain_name)
    {
        $returnType = '';
        $request = $this->domainAuthcodeRequest($domain_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainAuthcode'
     *
     * @param  string $domain_name Domain, wofür der Authcode abgerufen werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainAuthcodeRequest($domain_name)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainAuthcode'
            );
        }

        $resourcePath = '/domain/authcode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainAuthcodeEmail
     *
     * Domain Authinfo per E-Mail an den Inhaber versenden
     *
     * @param  string $domain_name Domain, wofür der Authcode versendet werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function domainAuthcodeEmail($domain_name)
    {
        $this->domainAuthcodeEmailWithHttpInfo($domain_name);
    }

    /**
     * Operation domainAuthcodeEmailWithHttpInfo
     *
     * Domain Authinfo per E-Mail an den Inhaber versenden
     *
     * @param  string $domain_name Domain, wofür der Authcode versendet werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainAuthcodeEmailWithHttpInfo($domain_name)
    {
        $returnType = '';
        $request = $this->domainAuthcodeEmailRequest($domain_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation domainAuthcodeEmailAsync
     *
     * Domain Authinfo per E-Mail an den Inhaber versenden
     *
     * @param  string $domain_name Domain, wofür der Authcode versendet werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainAuthcodeEmailAsync($domain_name)
    {
        return $this->domainAuthcodeEmailAsyncWithHttpInfo($domain_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainAuthcodeEmailAsyncWithHttpInfo
     *
     * Domain Authinfo per E-Mail an den Inhaber versenden
     *
     * @param  string $domain_name Domain, wofür der Authcode versendet werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainAuthcodeEmailAsyncWithHttpInfo($domain_name)
    {
        $returnType = '';
        $request = $this->domainAuthcodeEmailRequest($domain_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainAuthcodeEmail'
     *
     * @param  string $domain_name Domain, wofür der Authcode versendet werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainAuthcodeEmailRequest($domain_name)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainAuthcodeEmail'
            );
        }

        $resourcePath = '/domain/authcode_email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainAuthinfo2
     *
     * Domain Authinfo2 abrufen
     *
     * @param  string $domain_name Domain, wofür die Authinfo2 abgerufen werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function domainAuthinfo2($domain_name)
    {
        $this->domainAuthinfo2WithHttpInfo($domain_name);
    }

    /**
     * Operation domainAuthinfo2WithHttpInfo
     *
     * Domain Authinfo2 abrufen
     *
     * @param  string $domain_name Domain, wofür die Authinfo2 abgerufen werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainAuthinfo2WithHttpInfo($domain_name)
    {
        $returnType = '';
        $request = $this->domainAuthinfo2Request($domain_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation domainAuthinfo2Async
     *
     * Domain Authinfo2 abrufen
     *
     * @param  string $domain_name Domain, wofür die Authinfo2 abgerufen werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainAuthinfo2Async($domain_name)
    {
        return $this->domainAuthinfo2AsyncWithHttpInfo($domain_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainAuthinfo2AsyncWithHttpInfo
     *
     * Domain Authinfo2 abrufen
     *
     * @param  string $domain_name Domain, wofür die Authinfo2 abgerufen werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainAuthinfo2AsyncWithHttpInfo($domain_name)
    {
        $returnType = '';
        $request = $this->domainAuthinfo2Request($domain_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainAuthinfo2'
     *
     * @param  string $domain_name Domain, wofür die Authinfo2 abgerufen werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainAuthinfo2Request($domain_name)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainAuthinfo2'
            );
        }

        $resourcePath = '/domain/authinfo2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainCheck
     *
     * Domain Verfügbarkeit prüfen
     *
     * @param  string $domain_name Domain, welche geprüft werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function domainCheck($domain_name)
    {
        $this->domainCheckWithHttpInfo($domain_name);
    }

    /**
     * Operation domainCheckWithHttpInfo
     *
     * Domain Verfügbarkeit prüfen
     *
     * @param  string $domain_name Domain, welche geprüft werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainCheckWithHttpInfo($domain_name)
    {
        $returnType = '';
        $request = $this->domainCheckRequest($domain_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation domainCheckAsync
     *
     * Domain Verfügbarkeit prüfen
     *
     * @param  string $domain_name Domain, welche geprüft werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainCheckAsync($domain_name)
    {
        return $this->domainCheckAsyncWithHttpInfo($domain_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainCheckAsyncWithHttpInfo
     *
     * Domain Verfügbarkeit prüfen
     *
     * @param  string $domain_name Domain, welche geprüft werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainCheckAsyncWithHttpInfo($domain_name)
    {
        $returnType = '';
        $request = $this->domainCheckRequest($domain_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainCheck'
     *
     * @param  string $domain_name Domain, welche geprüft werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainCheckRequest($domain_name)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainCheck'
            );
        }

        $resourcePath = '/domain/check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainCreate
     *
     * Domain bestellen
     *
     * @param  string $domain_name Domain, welche bestellt werden soll (required)
     * @param  string $owner_c Inhaber Handle (required)
     * @param  string $admin_c Admin Handle (required)
     * @param  string $tech_c Tech Handle (required)
     * @param  string $zone_c Zone Handle (required)
     * @param  string $ns1 Erster Nameserver (required)
     * @param  string $ns2 Zweiter Nameserver (required)
     * @param  string $ns3 Dritter Nameserver (optional)
     * @param  string $ns4 Vierter Nameserver (optional)
     * @param  string $ns5 Fünfter Nameserver (optional)
     * @param  string $authinfo Authinfo, wird nur bei Transfer benötigt (optional)
     * @param  bool $create_zone Soll eine Zone auf unseren Nameservern erstellt werden? Dies gilt auch, wenn fremde Nameserver genutzt werden. (optional)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \c-sakel\RUBClient\Model\Domain[]
     */
    public function domainCreate($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3 = null, $ns4 = null, $ns5 = null, $authinfo = null, $create_zone = null)
    {
        list($response) = $this->domainCreateWithHttpInfo($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3, $ns4, $ns5, $authinfo, $create_zone);
        return $response;
    }

    /**
     * Operation domainCreateWithHttpInfo
     *
     * Domain bestellen
     *
     * @param  string $domain_name Domain, welche bestellt werden soll (required)
     * @param  string $owner_c Inhaber Handle (required)
     * @param  string $admin_c Admin Handle (required)
     * @param  string $tech_c Tech Handle (required)
     * @param  string $zone_c Zone Handle (required)
     * @param  string $ns1 Erster Nameserver (required)
     * @param  string $ns2 Zweiter Nameserver (required)
     * @param  string $ns3 Dritter Nameserver (optional)
     * @param  string $ns4 Vierter Nameserver (optional)
     * @param  string $ns5 Fünfter Nameserver (optional)
     * @param  string $authinfo Authinfo, wird nur bei Transfer benötigt (optional)
     * @param  bool $create_zone Soll eine Zone auf unseren Nameservern erstellt werden? Dies gilt auch, wenn fremde Nameserver genutzt werden. (optional)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \c-sakel\RUBClient\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function domainCreateWithHttpInfo($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3 = null, $ns4 = null, $ns5 = null, $authinfo = null, $create_zone = null)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainCreateRequest($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3, $ns4, $ns5, $authinfo, $create_zone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\c-sakel\RUBClient\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainCreateAsync
     *
     * Domain bestellen
     *
     * @param  string $domain_name Domain, welche bestellt werden soll (required)
     * @param  string $owner_c Inhaber Handle (required)
     * @param  string $admin_c Admin Handle (required)
     * @param  string $tech_c Tech Handle (required)
     * @param  string $zone_c Zone Handle (required)
     * @param  string $ns1 Erster Nameserver (required)
     * @param  string $ns2 Zweiter Nameserver (required)
     * @param  string $ns3 Dritter Nameserver (optional)
     * @param  string $ns4 Vierter Nameserver (optional)
     * @param  string $ns5 Fünfter Nameserver (optional)
     * @param  string $authinfo Authinfo, wird nur bei Transfer benötigt (optional)
     * @param  bool $create_zone Soll eine Zone auf unseren Nameservern erstellt werden? Dies gilt auch, wenn fremde Nameserver genutzt werden. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainCreateAsync($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3 = null, $ns4 = null, $ns5 = null, $authinfo = null, $create_zone = null)
    {
        return $this->domainCreateAsyncWithHttpInfo($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3, $ns4, $ns5, $authinfo, $create_zone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainCreateAsyncWithHttpInfo
     *
     * Domain bestellen
     *
     * @param  string $domain_name Domain, welche bestellt werden soll (required)
     * @param  string $owner_c Inhaber Handle (required)
     * @param  string $admin_c Admin Handle (required)
     * @param  string $tech_c Tech Handle (required)
     * @param  string $zone_c Zone Handle (required)
     * @param  string $ns1 Erster Nameserver (required)
     * @param  string $ns2 Zweiter Nameserver (required)
     * @param  string $ns3 Dritter Nameserver (optional)
     * @param  string $ns4 Vierter Nameserver (optional)
     * @param  string $ns5 Fünfter Nameserver (optional)
     * @param  string $authinfo Authinfo, wird nur bei Transfer benötigt (optional)
     * @param  bool $create_zone Soll eine Zone auf unseren Nameservern erstellt werden? Dies gilt auch, wenn fremde Nameserver genutzt werden. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainCreateAsyncWithHttpInfo($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3 = null, $ns4 = null, $ns5 = null, $authinfo = null, $create_zone = null)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainCreateRequest($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3, $ns4, $ns5, $authinfo, $create_zone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainCreate'
     *
     * @param  string $domain_name Domain, welche bestellt werden soll (required)
     * @param  string $owner_c Inhaber Handle (required)
     * @param  string $admin_c Admin Handle (required)
     * @param  string $tech_c Tech Handle (required)
     * @param  string $zone_c Zone Handle (required)
     * @param  string $ns1 Erster Nameserver (required)
     * @param  string $ns2 Zweiter Nameserver (required)
     * @param  string $ns3 Dritter Nameserver (optional)
     * @param  string $ns4 Vierter Nameserver (optional)
     * @param  string $ns5 Fünfter Nameserver (optional)
     * @param  string $authinfo Authinfo, wird nur bei Transfer benötigt (optional)
     * @param  bool $create_zone Soll eine Zone auf unseren Nameservern erstellt werden? Dies gilt auch, wenn fremde Nameserver genutzt werden. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainCreateRequest($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3 = null, $ns4 = null, $ns5 = null, $authinfo = null, $create_zone = null)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainCreate'
            );
        }
        // verify the required parameter 'owner_c' is set
        if ($owner_c === null || (is_array($owner_c) && count($owner_c) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_c when calling domainCreate'
            );
        }
        // verify the required parameter 'admin_c' is set
        if ($admin_c === null || (is_array($admin_c) && count($admin_c) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $admin_c when calling domainCreate'
            );
        }
        // verify the required parameter 'tech_c' is set
        if ($tech_c === null || (is_array($tech_c) && count($tech_c) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tech_c when calling domainCreate'
            );
        }
        // verify the required parameter 'zone_c' is set
        if ($zone_c === null || (is_array($zone_c) && count($zone_c) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zone_c when calling domainCreate'
            );
        }
        // verify the required parameter 'ns1' is set
        if ($ns1 === null || (is_array($ns1) && count($ns1) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ns1 when calling domainCreate'
            );
        }
        // verify the required parameter 'ns2' is set
        if ($ns2 === null || (is_array($ns2) && count($ns2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ns2 when calling domainCreate'
            );
        }

        $resourcePath = '/domain/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }
        // query params
        if ($owner_c !== null) {
            $queryParams['ownerC'] = ObjectSerializer::toQueryValue($owner_c, null);
        }
        // query params
        if ($admin_c !== null) {
            $queryParams['adminC'] = ObjectSerializer::toQueryValue($admin_c, null);
        }
        // query params
        if ($tech_c !== null) {
            $queryParams['techC'] = ObjectSerializer::toQueryValue($tech_c, null);
        }
        // query params
        if ($zone_c !== null) {
            $queryParams['zoneC'] = ObjectSerializer::toQueryValue($zone_c, null);
        }
        // query params
        if ($ns1 !== null) {
            $queryParams['ns1'] = ObjectSerializer::toQueryValue($ns1, null);
        }
        // query params
        if ($ns2 !== null) {
            $queryParams['ns2'] = ObjectSerializer::toQueryValue($ns2, null);
        }
        // query params
        if ($ns3 !== null) {
            $queryParams['ns3'] = ObjectSerializer::toQueryValue($ns3, null);
        }
        // query params
        if ($ns4 !== null) {
            $queryParams['ns4'] = ObjectSerializer::toQueryValue($ns4, null);
        }
        // query params
        if ($ns5 !== null) {
            $queryParams['ns5'] = ObjectSerializer::toQueryValue($ns5, null);
        }
        // query params
        if ($authinfo !== null) {
            $queryParams['authinfo'] = ObjectSerializer::toQueryValue($authinfo, null);
        }
        // query params
        if ($create_zone !== null) {
            $queryParams['createZone'] = ObjectSerializer::toQueryValue($create_zone, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDelete
     *
     * Domain löschen
     *
     * @param  string $domain_name Domain, welche gelöscht werden soll (required)
     * @param  string $date Datum, falls nicht angegeben, dann wird die Domain sofort gelöscht. (optional)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \c-sakel\RUBClient\Model\Domain[]
     */
    public function domainDelete($domain_name, $date = null)
    {
        list($response) = $this->domainDeleteWithHttpInfo($domain_name, $date);
        return $response;
    }

    /**
     * Operation domainDeleteWithHttpInfo
     *
     * Domain löschen
     *
     * @param  string $domain_name Domain, welche gelöscht werden soll (required)
     * @param  string $date Datum, falls nicht angegeben, dann wird die Domain sofort gelöscht. (optional)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \c-sakel\RUBClient\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDeleteWithHttpInfo($domain_name, $date = null)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainDeleteRequest($domain_name, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\c-sakel\RUBClient\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDeleteAsync
     *
     * Domain löschen
     *
     * @param  string $domain_name Domain, welche gelöscht werden soll (required)
     * @param  string $date Datum, falls nicht angegeben, dann wird die Domain sofort gelöscht. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDeleteAsync($domain_name, $date = null)
    {
        return $this->domainDeleteAsyncWithHttpInfo($domain_name, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDeleteAsyncWithHttpInfo
     *
     * Domain löschen
     *
     * @param  string $domain_name Domain, welche gelöscht werden soll (required)
     * @param  string $date Datum, falls nicht angegeben, dann wird die Domain sofort gelöscht. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDeleteAsyncWithHttpInfo($domain_name, $date = null)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainDeleteRequest($domain_name, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDelete'
     *
     * @param  string $domain_name Domain, welche gelöscht werden soll (required)
     * @param  string $date Datum, falls nicht angegeben, dann wird die Domain sofort gelöscht. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainDeleteRequest($domain_name, $date = null)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainDelete'
            );
        }

        $resourcePath = '/domain/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainIndex
     *
     * Alle Domains abrufen
     *
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \c-sakel\RUBClient\Model\Domain[]
     */
    public function domainIndex()
    {
        list($response) = $this->domainIndexWithHttpInfo();
        return $response;
    }

    /**
     * Operation domainIndexWithHttpInfo
     *
     * Alle Domains abrufen
     *
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \c-sakel\RUBClient\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function domainIndexWithHttpInfo()
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainIndexRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\c-sakel\RUBClient\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainIndexAsync
     *
     * Alle Domains abrufen
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainIndexAsync()
    {
        return $this->domainIndexAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainIndexAsyncWithHttpInfo
     *
     * Alle Domains abrufen
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainIndexAsyncWithHttpInfo()
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainIndexRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainIndex'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainIndexRequest()
    {

        $resourcePath = '/domain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistryStatus
     *
     * Domain Registry Status aktualisieren
     *
     * @param  string $domain_name Domain, welche aktualisiert werden soll (required)
     * @param  string $status Registry Status für Domain.  Mögliche Werte: ACTIVE &#x3D;&gt; Domain aktiv und konnektiert LOCK &#x3D;&gt; Domain aktiv und transfergeschützt, konnektiert HOLD &#x3D;&gt; Domain aktiv, nicht konnektiert HOLD_LOCK &#x3D;&gt; Domain aktiv und transfergeschützt, nicht konnektiert (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \c-sakel\RUBClient\Model\Domain[]
     */
    public function domainRegistryStatus($domain_name, $status)
    {
        list($response) = $this->domainRegistryStatusWithHttpInfo($domain_name, $status);
        return $response;
    }

    /**
     * Operation domainRegistryStatusWithHttpInfo
     *
     * Domain Registry Status aktualisieren
     *
     * @param  string $domain_name Domain, welche aktualisiert werden soll (required)
     * @param  string $status Registry Status für Domain.  Mögliche Werte: ACTIVE &#x3D;&gt; Domain aktiv und konnektiert LOCK &#x3D;&gt; Domain aktiv und transfergeschützt, konnektiert HOLD &#x3D;&gt; Domain aktiv, nicht konnektiert HOLD_LOCK &#x3D;&gt; Domain aktiv und transfergeschützt, nicht konnektiert (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \c-sakel\RUBClient\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistryStatusWithHttpInfo($domain_name, $status)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainRegistryStatusRequest($domain_name, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\c-sakel\RUBClient\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistryStatusAsync
     *
     * Domain Registry Status aktualisieren
     *
     * @param  string $domain_name Domain, welche aktualisiert werden soll (required)
     * @param  string $status Registry Status für Domain.  Mögliche Werte: ACTIVE &#x3D;&gt; Domain aktiv und konnektiert LOCK &#x3D;&gt; Domain aktiv und transfergeschützt, konnektiert HOLD &#x3D;&gt; Domain aktiv, nicht konnektiert HOLD_LOCK &#x3D;&gt; Domain aktiv und transfergeschützt, nicht konnektiert (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistryStatusAsync($domain_name, $status)
    {
        return $this->domainRegistryStatusAsyncWithHttpInfo($domain_name, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistryStatusAsyncWithHttpInfo
     *
     * Domain Registry Status aktualisieren
     *
     * @param  string $domain_name Domain, welche aktualisiert werden soll (required)
     * @param  string $status Registry Status für Domain.  Mögliche Werte: ACTIVE &#x3D;&gt; Domain aktiv und konnektiert LOCK &#x3D;&gt; Domain aktiv und transfergeschützt, konnektiert HOLD &#x3D;&gt; Domain aktiv, nicht konnektiert HOLD_LOCK &#x3D;&gt; Domain aktiv und transfergeschützt, nicht konnektiert (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistryStatusAsyncWithHttpInfo($domain_name, $status)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainRegistryStatusRequest($domain_name, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistryStatus'
     *
     * @param  string $domain_name Domain, welche aktualisiert werden soll (required)
     * @param  string $status Registry Status für Domain.  Mögliche Werte: ACTIVE &#x3D;&gt; Domain aktiv und konnektiert LOCK &#x3D;&gt; Domain aktiv und transfergeschützt, konnektiert HOLD &#x3D;&gt; Domain aktiv, nicht konnektiert HOLD_LOCK &#x3D;&gt; Domain aktiv und transfergeschützt, nicht konnektiert (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainRegistryStatusRequest($domain_name, $status)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainRegistryStatus'
            );
        }
        // verify the required parameter 'status' is set
        if ($status === null || (is_array($status) && count($status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status when calling domainRegistryStatus'
            );
        }

        $resourcePath = '/domain/registry_status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainResendVerificationEmail
     *
     * Domain Verifizierungsemail erneut versenden
     *
     * @param  string $domain_name Domain, wofür die Verifizierungsemail erneut gesendet werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \c-sakel\RUBClient\Model\Domain[]
     */
    public function domainResendVerificationEmail($domain_name)
    {
        list($response) = $this->domainResendVerificationEmailWithHttpInfo($domain_name);
        return $response;
    }

    /**
     * Operation domainResendVerificationEmailWithHttpInfo
     *
     * Domain Verifizierungsemail erneut versenden
     *
     * @param  string $domain_name Domain, wofür die Verifizierungsemail erneut gesendet werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \c-sakel\RUBClient\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function domainResendVerificationEmailWithHttpInfo($domain_name)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainResendVerificationEmailRequest($domain_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\c-sakel\RUBClient\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainResendVerificationEmailAsync
     *
     * Domain Verifizierungsemail erneut versenden
     *
     * @param  string $domain_name Domain, wofür die Verifizierungsemail erneut gesendet werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainResendVerificationEmailAsync($domain_name)
    {
        return $this->domainResendVerificationEmailAsyncWithHttpInfo($domain_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainResendVerificationEmailAsyncWithHttpInfo
     *
     * Domain Verifizierungsemail erneut versenden
     *
     * @param  string $domain_name Domain, wofür die Verifizierungsemail erneut gesendet werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainResendVerificationEmailAsyncWithHttpInfo($domain_name)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainResendVerificationEmailRequest($domain_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainResendVerificationEmail'
     *
     * @param  string $domain_name Domain, wofür die Verifizierungsemail erneut gesendet werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainResendVerificationEmailRequest($domain_name)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainResendVerificationEmail'
            );
        }

        $resourcePath = '/domain/resend_verification_email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRestore
     *
     * Domain wiederherstellen
     *
     * @param  string $domain_name Domain (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \c-sakel\RUBClient\Model\Domain[]
     */
    public function domainRestore($domain_name)
    {
        list($response) = $this->domainRestoreWithHttpInfo($domain_name);
        return $response;
    }

    /**
     * Operation domainRestoreWithHttpInfo
     *
     * Domain wiederherstellen
     *
     * @param  string $domain_name Domain (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \c-sakel\RUBClient\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRestoreWithHttpInfo($domain_name)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainRestoreRequest($domain_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\c-sakel\RUBClient\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRestoreAsync
     *
     * Domain wiederherstellen
     *
     * @param  string $domain_name Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRestoreAsync($domain_name)
    {
        return $this->domainRestoreAsyncWithHttpInfo($domain_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRestoreAsyncWithHttpInfo
     *
     * Domain wiederherstellen
     *
     * @param  string $domain_name Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRestoreAsyncWithHttpInfo($domain_name)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainRestoreRequest($domain_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRestore'
     *
     * @param  string $domain_name Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainRestoreRequest($domain_name)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainRestore'
            );
        }

        $resourcePath = '/domain/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainShow
     *
     * Einzelne Domain abrufen
     *
     * @param  string $domain_name Domain, welche abgerufen werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \c-sakel\RUBClient\Model\Domain[]
     */
    public function domainShow($domain_name)
    {
        list($response) = $this->domainShowWithHttpInfo($domain_name);
        return $response;
    }

    /**
     * Operation domainShowWithHttpInfo
     *
     * Einzelne Domain abrufen
     *
     * @param  string $domain_name Domain, welche abgerufen werden soll (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \c-sakel\RUBClient\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function domainShowWithHttpInfo($domain_name)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainShowRequest($domain_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\c-sakel\RUBClient\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainShowAsync
     *
     * Einzelne Domain abrufen
     *
     * @param  string $domain_name Domain, welche abgerufen werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainShowAsync($domain_name)
    {
        return $this->domainShowAsyncWithHttpInfo($domain_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainShowAsyncWithHttpInfo
     *
     * Einzelne Domain abrufen
     *
     * @param  string $domain_name Domain, welche abgerufen werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainShowAsyncWithHttpInfo($domain_name)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainShowRequest($domain_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainShow'
     *
     * @param  string $domain_name Domain, welche abgerufen werden soll (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainShowRequest($domain_name)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainShow'
            );
        }

        $resourcePath = '/domain/show';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainUndelete
     *
     * Domain Löschung zurückziehen
     *
     * @param  string $domain_name Domain (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \c-sakel\RUBClient\Model\Domain[]
     */
    public function domainUndelete($domain_name)
    {
        list($response) = $this->domainUndeleteWithHttpInfo($domain_name);
        return $response;
    }

    /**
     * Operation domainUndeleteWithHttpInfo
     *
     * Domain Löschung zurückziehen
     *
     * @param  string $domain_name Domain (required)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \c-sakel\RUBClient\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function domainUndeleteWithHttpInfo($domain_name)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainUndeleteRequest($domain_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\c-sakel\RUBClient\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainUndeleteAsync
     *
     * Domain Löschung zurückziehen
     *
     * @param  string $domain_name Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainUndeleteAsync($domain_name)
    {
        return $this->domainUndeleteAsyncWithHttpInfo($domain_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainUndeleteAsyncWithHttpInfo
     *
     * Domain Löschung zurückziehen
     *
     * @param  string $domain_name Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainUndeleteAsyncWithHttpInfo($domain_name)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainUndeleteRequest($domain_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainUndelete'
     *
     * @param  string $domain_name Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainUndeleteRequest($domain_name)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainUndelete'
            );
        }

        $resourcePath = '/domain/undelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainUpdate
     *
     * Domain aktualisieren
     *
     * @param  string $domain_name Domain, welche aktualisiert werden soll (required)
     * @param  string $owner_c Inhaber Handle (required)
     * @param  string $admin_c Admin Handle (required)
     * @param  string $tech_c Tech Handle (required)
     * @param  string $zone_c Zone Handle (required)
     * @param  string $ns1 Erster Nameserver (required)
     * @param  string $ns2 Zweiter Nameserver (required)
     * @param  string $ns3 Dritter Nameserver (optional)
     * @param  string $ns4 Vierter Nameserver (optional)
     * @param  string $ns5 Fünfter Nameserver (optional)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \c-sakel\RUBClient\Model\Domain[]
     */
    public function domainUpdate($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3 = null, $ns4 = null, $ns5 = null)
    {
        list($response) = $this->domainUpdateWithHttpInfo($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3, $ns4, $ns5);
        return $response;
    }

    /**
     * Operation domainUpdateWithHttpInfo
     *
     * Domain aktualisieren
     *
     * @param  string $domain_name Domain, welche aktualisiert werden soll (required)
     * @param  string $owner_c Inhaber Handle (required)
     * @param  string $admin_c Admin Handle (required)
     * @param  string $tech_c Tech Handle (required)
     * @param  string $zone_c Zone Handle (required)
     * @param  string $ns1 Erster Nameserver (required)
     * @param  string $ns2 Zweiter Nameserver (required)
     * @param  string $ns3 Dritter Nameserver (optional)
     * @param  string $ns4 Vierter Nameserver (optional)
     * @param  string $ns5 Fünfter Nameserver (optional)
     *
     * @throws \c-sakel\RUBClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \c-sakel\RUBClient\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function domainUpdateWithHttpInfo($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3 = null, $ns4 = null, $ns5 = null)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainUpdateRequest($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3, $ns4, $ns5);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\c-sakel\RUBClient\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainUpdateAsync
     *
     * Domain aktualisieren
     *
     * @param  string $domain_name Domain, welche aktualisiert werden soll (required)
     * @param  string $owner_c Inhaber Handle (required)
     * @param  string $admin_c Admin Handle (required)
     * @param  string $tech_c Tech Handle (required)
     * @param  string $zone_c Zone Handle (required)
     * @param  string $ns1 Erster Nameserver (required)
     * @param  string $ns2 Zweiter Nameserver (required)
     * @param  string $ns3 Dritter Nameserver (optional)
     * @param  string $ns4 Vierter Nameserver (optional)
     * @param  string $ns5 Fünfter Nameserver (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainUpdateAsync($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3 = null, $ns4 = null, $ns5 = null)
    {
        return $this->domainUpdateAsyncWithHttpInfo($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3, $ns4, $ns5)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainUpdateAsyncWithHttpInfo
     *
     * Domain aktualisieren
     *
     * @param  string $domain_name Domain, welche aktualisiert werden soll (required)
     * @param  string $owner_c Inhaber Handle (required)
     * @param  string $admin_c Admin Handle (required)
     * @param  string $tech_c Tech Handle (required)
     * @param  string $zone_c Zone Handle (required)
     * @param  string $ns1 Erster Nameserver (required)
     * @param  string $ns2 Zweiter Nameserver (required)
     * @param  string $ns3 Dritter Nameserver (optional)
     * @param  string $ns4 Vierter Nameserver (optional)
     * @param  string $ns5 Fünfter Nameserver (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainUpdateAsyncWithHttpInfo($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3 = null, $ns4 = null, $ns5 = null)
    {
        $returnType = '\c-sakel\RUBClient\Model\Domain[]';
        $request = $this->domainUpdateRequest($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3, $ns4, $ns5);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainUpdate'
     *
     * @param  string $domain_name Domain, welche aktualisiert werden soll (required)
     * @param  string $owner_c Inhaber Handle (required)
     * @param  string $admin_c Admin Handle (required)
     * @param  string $tech_c Tech Handle (required)
     * @param  string $zone_c Zone Handle (required)
     * @param  string $ns1 Erster Nameserver (required)
     * @param  string $ns2 Zweiter Nameserver (required)
     * @param  string $ns3 Dritter Nameserver (optional)
     * @param  string $ns4 Vierter Nameserver (optional)
     * @param  string $ns5 Fünfter Nameserver (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainUpdateRequest($domain_name, $owner_c, $admin_c, $tech_c, $zone_c, $ns1, $ns2, $ns3 = null, $ns4 = null, $ns5 = null)
    {
        // verify the required parameter 'domain_name' is set
        if ($domain_name === null || (is_array($domain_name) && count($domain_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_name when calling domainUpdate'
            );
        }
        // verify the required parameter 'owner_c' is set
        if ($owner_c === null || (is_array($owner_c) && count($owner_c) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_c when calling domainUpdate'
            );
        }
        // verify the required parameter 'admin_c' is set
        if ($admin_c === null || (is_array($admin_c) && count($admin_c) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $admin_c when calling domainUpdate'
            );
        }
        // verify the required parameter 'tech_c' is set
        if ($tech_c === null || (is_array($tech_c) && count($tech_c) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tech_c when calling domainUpdate'
            );
        }
        // verify the required parameter 'zone_c' is set
        if ($zone_c === null || (is_array($zone_c) && count($zone_c) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zone_c when calling domainUpdate'
            );
        }
        // verify the required parameter 'ns1' is set
        if ($ns1 === null || (is_array($ns1) && count($ns1) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ns1 when calling domainUpdate'
            );
        }
        // verify the required parameter 'ns2' is set
        if ($ns2 === null || (is_array($ns2) && count($ns2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ns2 when calling domainUpdate'
            );
        }

        $resourcePath = '/domain/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain_name !== null) {
            $queryParams['domainName'] = ObjectSerializer::toQueryValue($domain_name, null);
        }
        // query params
        if ($owner_c !== null) {
            $queryParams['ownerC'] = ObjectSerializer::toQueryValue($owner_c, null);
        }
        // query params
        if ($admin_c !== null) {
            $queryParams['adminC'] = ObjectSerializer::toQueryValue($admin_c, null);
        }
        // query params
        if ($tech_c !== null) {
            $queryParams['techC'] = ObjectSerializer::toQueryValue($tech_c, null);
        }
        // query params
        if ($zone_c !== null) {
            $queryParams['zoneC'] = ObjectSerializer::toQueryValue($zone_c, null);
        }
        // query params
        if ($ns1 !== null) {
            $queryParams['ns1'] = ObjectSerializer::toQueryValue($ns1, null);
        }
        // query params
        if ($ns2 !== null) {
            $queryParams['ns2'] = ObjectSerializer::toQueryValue($ns2, null);
        }
        // query params
        if ($ns3 !== null) {
            $queryParams['ns3'] = ObjectSerializer::toQueryValue($ns3, null);
        }
        // query params
        if ($ns4 !== null) {
            $queryParams['ns4'] = ObjectSerializer::toQueryValue($ns4, null);
        }
        // query params
        if ($ns5 !== null) {
            $queryParams['ns5'] = ObjectSerializer::toQueryValue($ns5, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
